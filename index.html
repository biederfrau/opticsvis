<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>OPTICSvis</title>
    <link rel="stylesheet" href="stylesheet.css" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
</head>

<body>
<nav class="sidebar">
    <div class="elem">
        <a href="#m1">Milestone 1</a>
    </div>

    <div class="elem">
        <a href="#m2">Milestone 2</a>
    </div>

    <div class="elem">
        <a href="#m3">Milestone 3</a>
    </div>

    <div class="elem">
        <a href="#m4">Milestone 4</a>
    </div>
</nav>

<div class="content">
    <h2 class="title">OPTICS<sub>vis</sub>: clustering, visualized</h2>
    <hr/>

    <section id="m1">
        <h2>Milestone 1</h2>

        <h3>Introduction</h3>

        <p>
            Our project idea is to visualize the resulting data from running the
            OPTICS algorithm on a given data set. OPTICS does not generate a
            simple mapping of points to a cluster ID, but rather outputs a list
            of reachability data—that is, the length (given by, e.g., the
            euclidean distance between those two points) that the algorithm had
            to jump from a given point to another. Short distances are preferred by
            the algorithm, so a series of short jumps likely marks a cluster.
        </p>

        <p>
            However, in the end the user is looking at nothing but numbers and has to discern
            the patterns in the data himself. As such, the first step after running OPTICS
            is usually to draw a bar chart, which makes this task much easier.
        </p>

        <p>
            As such, visualization is arguably already a core component of cluster analysis
            when using OPTICS. Why not allow for further manipulation of the algorithm, allowing
            to specify parameters such as the minimum point size to qualifiy as a cluster, or the
            cutoff distance that is applied onto the reachability data to define the actual clusters?
        </p>

        <p>
            Furthermore, OPTICS is inherently capable of producing hierarchial
            clusterings, but this information is oftentimes discarded in favor of
            a simpler representation. Procuring an visualization method that is
            still simple, but allows for evaluation of hierarchial clusters is
            surely a worthwile undertaking, and one that we will strive for.
        </p>

        <img id="wiki-optics" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f9/OPTICS.svg/712px-OPTICS.svg.png"/>
        <div class="img-subtext">OPTICS. source: wikipedia</div>

        <h3>Why do this and to what scope?</h3>

        <p>
            Not many tools exist that take on this subject, although notable
            projects exist, especially Clustervision <a href="#clustervision">[1]</a>
            and a DBSCAN visualization that we found <a href="#dbscan">[2]</a>,
            the latter of which only visualizes how DBSCAN goes about finding
            clusters (i.e. shows the epsilon neighborhoods). It is notable that
            DBSCAN results in a simple partition of points into clusters along
            with some metadata (e.g. core points versus edge points).
        </p>

        <p>
            Clustervision is an especially powerful tool and takes on a
            multitude of algorithms (including OPTICS) and offers additional
            tooling like dimension reduction using TSNE. One of the core tasks
            of this tool is to validate the results of the algorithm—i.e.
            enable the user to check out the features of points in a cluster
            and see the relations between data that caused them to be
            classified into the same cluster.
        </p>

        <p>
            This is something that we do not want to do, as we strongly feel that
            this is out of bounds for us. We want to make an example of simple
            data (i.e. low dimensional and spatial, a list of real points) and
            how the results given by OPTICS relate to this data set and the used
            settings, and show the partition derived from the reachability data.
        </p>
    </section>

    <section>
        <h3>Project details</h3>

        <dl>
            <dt>Project type</dt>
            <dd>Design study</dd>

            <dt>Group</dt>
            <dd>
                <ul>
                    <li><a href="mailto:sonja.biedermann@univie.ac.at">Sonja Biedermann (01402891)</a></li>
                    <li><a href="mailto:a01463926@unet.univie.ac.at">Christian Permann (01463926)</a></li>
                </ul>
            </dd>

            <dt>Tasks</dt>
            <dd>
                <ul>
                    <li>Visualize data (as point clouds)</li>
                    <li>Visualize OPTICS results in an interactive and accessible way</li>
                    <li>Experiment with different settings for the algorithm (educational aspect)</li>
                </ul>
            </dd>

            <dt>Users</dt>
            <dd>
                <ul>
                    <li>Students interested in the algorithm</li>
                    <li>Teachers for presentation purposes</li>
                    <li>Scientists that just want something to quickly use density based clustering</li>
                    <li>Scientists that want to see if this algorithm fits their requirements</li>
                </ul>
            </dd>

            <dt>Dataset</dt>
            <dd>User provided or predefined points</dd>
        </dl>
    </section>

    <section>
        <h3>Preliminary Project Solution</h3>

        <img src="m1/scan.jpg" width="100%"/>
        <div class="img-subtext">Sketch of a preliminary solution.</div>

        <p>
            A preliminary solution could consist out of a scatter plot visualizing the
            input data, a bar plot visualizing the reachability data, as well as a heat
            map that visualizes similarities. Another view may be used to show miscellaneous
            metadata such as the number of points per cluster. A small dashboard is provided
            to change algorithm parameters.
        </p>
    </section>

    <section>
        <h3>Separation of Tasks</h3>
        <table width="100%">
            <tr>
                <th></th>
                <th>Sonja</th>
                <th>Christian</th>
            </tr>

            <tr>
                <th>Website (Content)</th>
                <td>85%</td>
                <td>15%</td>
            </tr>

            <tr>
                <th>Idea</th>
                <td>15%</td>
                <td>85%</td>
            </tr>

            <tr>
                <th>Solution Sketch</th>
                <td>50%</td>
                <td>50%</td>
            </tr>
        </table>
    </section>

    <section>
        <h3>References</h3>
        <ol class="bib">
            <li id="clustervision"><a href="http://perer.org/papers/adamPerer-Clustervision-VAST2017.pdf">Clustervision:
                Visual Supervision of Unsupervised Clustering (opens a .pdf)</a></li>
            <li id="dbscan"><a href="https://www.naftaliharris.com/blog/visualizing-dbscan-clustering/">Visualizing
                DBSCAN clustering</a></li>
        </ol>
    </section>

    <section id="m2">
        <h2>Milestone 2</h2>
        <h3>Chart Pool</h3>

        Our data is twofold, first: the data to be clustered, and then the actual output (along with metadata that is
        derived from the output).

        <dl class="chart-list">
          <dt>Scatter plot</dt>
          <dd>
            <p>
              Since we've decided to deal with exclusively real-valued data points, a scatter plot
              is a natural visualization choice. However, especially with excessively many points,
              scatter plots may start to become unwieldy, and, especially
              considering svg-drawing in the browser, slow.
            </p>
          </dd>

          <dt>Bar chart (split dimensions)</dt>
          <dd>
            <img src="m2/split-dim.png" width="100%"/>
            <div class="img-subtext">An image is worth a thousand words</div>

            <p>
              We feel that given very large data sets, this might be an interesting way to aggregate
              it. It works as follows: the dimensions are split up into two (or however many dimensions
              there are) histograms that bin the number of points given in some range. That way the
              data distribution is visualized.
            </p>

            <p>
              To show the correlation between the two dimensions, we propose that
              we add a color cue.  On hovering a bar, the bars of the other
              dimension will change color to show the distribution of the points
              that were put into the corresponding bin, e.g. turn blue to show that
              few points of the selected bin were put into the other dimension's
              bin or green for quite many.
            </p>

            <p>
              However, this would at best provide a rough overview over the data distribution (which
              is already a pretty sweet deal when you're dealing with Big Data, but we probably won't)
              and might be alienating to any users, who probably expect a simple scatter plot instead.
            </p>
          </dd>

          <dt>Heat map (similarities)</dt>
          <dd>
            <p>
              This chart displays the points in the output order on both axes and maps the colors
              to the similarity (e.g. inverse distance) of the points. This way, clusters are visible
              along the diagonal. Hierarchial structures are also visible.
            </p>
          </dd>

          <dt>Heat map (jump distances)</dt>
          <dd>
            <p>
              An alternative application of a heat map would be to sort of merge the scatter plot
              with a heat map, dividing the area into small rectangles and coloring them according
              to the jumps that were made between points---with small jumps being high similarity.
              This way, we actually display the densities of certain regions, which are already enough
              to reveal any clusters, and get rid of the actual points (which may be toggled on demand)
              to avoid clutter in case of large data.
            </p>

            <p>
              This may, however, be hard to implement---or at least implement so that it works well.
            </p>
          </dd>

          <dt>Scatter plot with jump paths</dt>
          <dd>
            <p>
              Another spin on the scatter plot would be to show the actual jumps that the algorithm makes
              between points, like it is done in <a href="#wiki-optics">the graphic at the top of the page</a>.
              This would illustrate how the algorithm works and provide a connection to the reachability data.
            </p>
          </dd>

          <dt>Bar chart (reachability)</dt>
          <dd>
            <p>
              Although we think that bar charts = boring charts, we think that the reachability is
              best visualized using, well, bar charts. For one part, they allow for easy comparison of
              reachability lengths, as the height of the bar immediately corresponds to the length of the
              jump, so no thinking required.
            </p>

            <p>
              Furthermore, bar charts have always been used to visualize the reachability, so it has
              become canon. Someone who is well-aquainted with the algorithm might be thrown off if we
              used something different.
            </p>
          </dd>

          <dt>Bar chart (cluster sizes)</dt>
          <dd>
            <p>
              It may be desirable to also show the make-up of the data using the different
              cluster sizes. This can be done using a bar chart.
            </p>
          </dd>

          <dt>Bubble chart (cluster sizes)</dt>
          <dd>
            <p>
              It is also possible to display the cluster size information in a more fun way
              by using a bubble chart. However, we feel that the use of spheres may be a bad
              choice---historically, the OPTICS algorithm was a great idea because it is able to
              find clusters that are NOT sphere shaped, by looking at densities. A bubble chart
              looks like clusters, so it may be confusing to imply that the clusters in the data
              are somehow also spherical.
            </p>
          </dd>

          <dt>Area chart (clusters with different cutoffs)</dt>
          <dd>
            <p>
              The cutoff distance is <em>the</em> parameter to play around with, and can
              drastically alter the resulting clustering. As a reminder, the cutoff distance
              mandates which points (whose jump distances all fall below the cutoff) get lumped
              together in a cluster.
            </p>

            <p>
              We could draw an area chart over different cutoff distances and show how the clusters
              start to fall together given larger cutoffs. This could then be used to indentify critical
              cutoffs, i.e. after how large a cutoff the result starts to be no longer useful. This
              also tells a story on graph hierarchies, with larger cutoffs showing clusters that would be
              further up on the dendogram.
            </p>

            <p>
              This could also be used to display effects of different parameters, e.g. the min points
              parameter. It could also be altered to only show the ratio between points classified as
              noise versus points classified as cluster points.
            </p>
          </dd>

          <dt>Dendogram (hierarchial clusters)</dt>
          <dd>
            <p>
              A dendogram is the weapon of choice when wanting to show
              hierarchies in a clustering.  Here, we could define different
              cutoffs for sourcing the data to display, although this might be
              tricky to get to work right on many different data sets.  This
              could be solved by enabling user intervention, i.e. having the
              user pick cutoffs (which is also a great thing to play around
              with).
            </p>

            <p>
              The implementation of this might be a little more involved.
            </p>
          </dd>

          <dt>Line chart (points classified over time)</dt>
          <dd>
            <p>
              It might be useful to show the progression of the algorithm over time?
                This could also give a feeling for the algorithmic complexity of the algorithm,
                and how different parameters affect its runtime in contrast to the amount of points
                for a specific data set.
              We could also use an area chart because line charts tend to look flimsy.
            </p>
          </dd>
        </dl>

        <h3>Mockup 1</h3><!--{{{-->
        <img src="m2/mockup1.png" width="100%"/>
        <p>
            The charts [1] and [3] are necessary in each of our visualizations since those are fundamentally important
            for understanding the algorithm. The right hand size charts can be exchanged for other plots that show
            different meta information.
            <br/><br/>
            Chart [1] is needed because it is the only reasonably viable option to actually show the data, that is
            being worked on. Without this chart there is no way to intuitively compare the algorithm with what a
            human would conceive as clusters.
            <br/>
            Chart [3] is needed because this is the output of the algorithm. If someone later on wants to use
            the algorithm the only thing they will get as output is the data visualized in this chart. Since the
            whole point of our implementation is to explain the algorithm and visualize its results, it is essential
            to show this data. All other charts are based around the idea to make this data more understandable.

        </p>
        <ol>
            <li>
                Shows the points with their cluster coded as color
            </li>
            <li>
                Shows the clusters with the amount of points contained, as well as the noise points in gray.
            </li>
            <li>
                Shows the Reachability Plot with the reachability distance for each point and the cutoff line that
                defines clusters
            </li>
            <li>
                Shows the average reachability distance within the clusters, lower meaning a denser cluster
            </li>
        </ol>

        <ul>
            <li>
                When mousing over any of the bar charts the points belonging to the according cluster will be
                highlighted in all other charts, mousing over points has the reverse effect.
            </li>
            <li>
                Zooming is enabled inside of the scatter plot.
            </li>
            <li>
                Clicking on a bar of a bar chart hides other points in the scatter and reachability plot and gives
                the other bars transparency.
            </li>
            <li>
                The cutoff line can be dragged to redefine clusters. All charts and data will be reevaluated and
                changed accordingly.
            </li>
            <br/>
            <li>
                The "Data"-Button lets you copy text into a text box, which gets interpreted and used as data for the
                algorithm.
            </li>
            <li>
                The "Settings"-Button lets you define the Epsilon and MIN-Points for the algorithm as well as
                define a value from which on distances are being handled as if unreachable ("Context Infinity").
                This value is therefor also the upper bound for the reachability plot.
            </li>
        </ul>
        <h4>
            Advantages:
        </h4>
        <ul>
            <li>Nicely shows the points</li>
            <li>Cluster information can be seen easily</li>
        </ul>
        <h4>
            Disadvantages:
        </h4>
        <ul>
            <li>Difficult to correlate points with reachability value</li>
            <li>May produce ugly visualization with bad parameters</li>
        </ul><!--}}}-->

        <h3>Mockup 2</h3><!--{{{-->
        <img src="m2/mockup2.png" width="100%"/>
        <p>
            Charts [2] and [4] (Mockup 1) may be swaped out for those or the heat map(sketched in m1).
        </p>
        <ol>
            <li>
                Shows classification progress over time.
            </li>
            <li>
                Shows the clusters with the amount of points contained, as well as the noise points in gray.
            </li>
        </ol>
        <h4>
        Advantages:
        </h4>
        <ul>
            <li>(chart 1) Shows algorithm progress over time</li>
            <li>(chart 2) Data partitioning(result) may be easy to recognize</li>
            <li>(heat map) Can reduce the dimensionality to 2 if the data set has more than 2 dimensions
            and visualizes nicely cluster and sub cluster structures without need for a cut off line</li>
        </ul>
        <h4>
            Disadvantages:
        </h4>
        <ul>
            <li>(chart 1) It is difficult to predict how useful progress over time is? </li>
            <li>(chart 2) A bar chart may be better fit and more readable</li>
            <li>(heat map) May need some thought to be understood</li>
        </ul><!--}}}-->

        <h3>Mockup 3</h3><!--{{{-->
        <img src="m2/mockup3.png" width="100%"/>
        <div class="img-subtext">Detail view of the visualization components</div>

        <p>
          The details on this mockup are not quite accurate but give a rough idea
          of how the results for a given data set may look like.
        </p>

        <p>
          For this mockup, we have picked 5 charts from the chart pool above,
          namely a density map that also shows points (these can be toggled off
          to decrease clutter), a scatter plot that also displays the jumps
          between points that the algorithm made, the good old bar chart that
          shows the reachability distance in the order that the algorithm
          generated them, as well as an area chart that gives an overview over
          how the clusters change with increasing cutoff distances, and another
          simple bar chart that shows cluster sizes (or noise, which are
          aggregated into one pseudocluster) by number of points.
        </p>

        <p>
          The charts are enumerated starting at the top left and clockwise.
        </p>

        <dl class="chart-list">
          <dt>Density map</dt>
          <dd>
            <p>
              This view shows a density map. Since OPTICS is a density-based clustering algorithm,
              displaying the densities is a natural choice.
            </p>

            <p>
              It might be desirable to view the actual points, however, so an
              option for toggling the data points (as in a normal scatterplot)
              should be included. These points could then also be colored to
              correlate with the other views.
            </p>
          </dd>

          <dt>Bar chart (cluster sizes)</dt>
          <dd>
            <p>
              This view shows the cluster sizes. The colors are picked to relate
              to the other views.
            </p>
          </dd>

          <dt>Scatter plot with jump paths</dt>
          <dd>
            <p>
              This view shows the data points along with the paths that correlate to the jumps
              displayed in the reachability bar chart. The jumps are colored according to the
              cluster, according to the colors of the bar chart and other views. Hovering a
              bar of the reachability chart should highlight the corresponding edge.
            </p>
          </dd>

          <dt>Area chart (different cutoffs)</dt>
          <dd>
            <p>
              The area chart shows how the ratio of the different clusters change as the cutoff distance
              increases. This shows some hierarchical information as only adjacent clusters merge. The effect
              can be replicated by dragging the cutoff bar on chart 5.
            </p>
          </dd>

          <dt>Bar chart (reachability distances)</dt>
          <dd>
            <p>
              This view shows the reachability distances (the lengths of the jumps) in the order
              computed by the algorithm. This is a staple OPTICS chart and would probably be included
              in even the most avant garde OPTICS visualizations.
            </p>

            <p>
              A bar can be used to change the current cutoff distance. Multiple cutoff bars are also
              possible, which would then reveal hierarchical cluster structures (e.g. as shown in the
              density map, with denser inner regions (cores) and less dense outer regions ("suburbs")).
            </p>
          </dd>
        </dl>

        <h4>User interface</h4>
        <img src="m2/mockup3-ui.jpg" width="100%"/>
        <div class="img-subtext">Minimal user interface for mockup 3</div>

        <p>
          The user interface will consist of a side bar on the right side with three
          sections (buttons) to press. On press the bar will expand a little and
          show general information about the algorithm (about), or show a text field
          for pasting data (data), or show settings for the algorithm (in the form of
          sliders for e.g. cutoff distance, most likely).
        </p><!--}}}-->

        <h3>Visualization techniques</h3><!--{{{-->

        <p>
          Most of the visualization techniques that we picked can find use in any constellation of charts,
          so we will cover them in a general manner.
        </p>

        <dl class="chart-list">
          <dt>Aggregation</dt>
          <dd>
            <p>
              Clustering is a form of aggregation, so any clustering
              visualization will make use of aggregation as soon as the points
              are assigned their cluster ID and this is somehow visualized, as
              the points are then aggregated into groups defined by their
              cluster ID. In our case, the cluster membership is communicated
              using colors.
            </p>
          </dd>

          <dt>Heat maps</dt>
          <dd>
            <p>
              A clustering can be visualized by placing similar values in close
              proximity and using their similarity as an index into a color
              scheme. This is displayed in mockup 4.
            </p>

            <p>
              We are unclear on the technicalities, but the density map of mockup 3
              could possibly also be considered a heatmap mapping point densities to
              colors.
            </p>
          </dd>

          <dt>Tooltips</dt>
          <dd>
            <p>
              We will be using tooltips to convey exact data---e.g. a bar chart
              depicting cluster sizes can only convey approximate data (unless
              you reverse-engineer the formula for the rectangle size and count
              the pixels somehow), but hovering the bar will create a popup
              that will give the exact size of the cluster in question.
            </p>
          </dd>

          <dt>Brushing &amp; Linking / Context and Focus / Zoom</dt>
          <dd>
            <p>
              We plan on incorporating especially linking and having other
              views react to selections made in different views, e.g.
              highlighting a reachability bar in the reachability distance bar
              chart will highlight the corresponding jump-path in the scatter
              plot with jump paths (see mockup 3).
            </p>

            <p>
              Brushing can be used on either the scatter plot (selecting a
              group of points) or the reachability distance bar chart
              (selecting also a group of points, but in a given order). The
              first variant would update the other views to only show data
              relating to the points that are contained in the selection
              (possibly prompting expensive recomputation), while the second
              variant would zoom in on the scatterplot, as consecutive points
              in the bar chart are expected to be in close proximity to each
              other.
            </p>

            <p>
              This behavior somewhat resembles the context and focus pattern, with
              e.g. the reachability acting as a context and the other views reacting to
              focus the selection.
            </p>
          </dd>

          <dt>Filter</dt>
          <dd>
            <p>
              Selecting a cluster (in the cluster size chart) will all relevant views focus
              on data pertaining to only this one cluster. This overlaps somewhat with the
              previous techniques.
            </p>
          </dd>
        </dl><!--}}}-->

        <h3>Scenario of use</h3><!--{{{-->
        <p>
            A typical scenario could be a teacher at a university, wanting to show how OPTICS can be used.
            For this said teacher would first enter data in the corresponding menu and edit the algorithm settings.
            Next the data is shown and the different charts show the clusters and some meta data.
            With those the reachability plot, which usually is the only output, can be further explained for better
            understanding. Additionally the parameters and cutoff line can be adjusted to see how those affect the output.
        </p>
        <p>
            An even more concrete step by step way to use this for research could be:
        </p>
        <ul>
            <li>Click "Data" Field</li>
            <li>Load in some data</li>
            <li>Go to "Settings"</li>
            <li>Define Eps/MINPts/"Infinity"</li>
            <li>Show the scatter plot (the classification may not be nice)</li>
            <li>Look at the heat map, if it looks fine change cut off line, otherwise change settings</li>
            <li>Further tweak settings and/or cut off</li>
            <li>Analyse cluster meta information (e.g. cluster size)</li>
            <li>Think about how good this algorithm worked for given data set / how content you are with the results</li>
            <li>Rerun experiments / Decide if this algorithm is fit for given problem</li>
            <li>Use gained knowledge as you want</li>
        </ul><!--}}}-->

        <h3>Implementation details</h3><!--{{{-->

        <p>
          We will be using d3.js. We have tried it out (obviously) and have a rough idea
          of what it can do, and think that our ideas can be easily realized using it.
        </p><!--}}}-->

        <h3>Milestones</h3>

        <p>
          Milestones are sequential in nature (they do build up on each other),
          but work will probably not stop immediately at the due date but fade
          out. It might be necessary to go back to work done for a previous
          milestone.
        </p>

        <dl class="milestone-list">
          <dt>Finalize ideation phase</dt>
          <dd>
            <p>
              Pick best parts of all mockups, combine into one and further flesh
              out. Think harder about feasibility (i.e. how hard to implement).
            </p>

            <p><b>Assigned to:</b> all</p>
            <p><b>Due:</b> 23rd November</p>
          </dd>

          <dt>Preparation (non-vis parts)</dt>
          <dd>
            <p>
              Implement the OPTICS algorithm in a variant that supports everything
              we need for visualization (data collection, data parsing, etc.). Set up
              a basic skeleton including JS and HTML and UI parts.
            </p>

            <p>
              <b>Assigned to:</b>
              <ul>
                <li>Algorithm: Christian</li>
                <li>Skeleton: Sonja</li>
              </ul>
            </p>
            <p><b>Due:</b> 26th November</p>
          </dd>

          <dt>Non (or hardly) interactive visualization</dt>
          <dd>
            <p>
              Implement all views in a static way, without filtering and linking and stuff.
              Obviously keep in mind that this will later need to be implemented and take
              precautions to make this as painless as possible, don't just hamfist it like
              a crazed brogrammer.
            </p>

            <p>
              <b>Assigned to:</b>
              <ul>
                <li>Half of views: Christian</li>
                <li>Other half: Sonja</li>
                <li>Pick pretty colors and stuff: Sonja</li>
              </ul>
            </p>
            <p><b>Due:</b> 29th December</p>
          </dd>

          <dt>Interactive elements</dt>
          <dd>
            <p>
              Add interactivity, i.e. draggable elements, linky and brushy things,
              zooming. Finish the UI.
            </p>

            <p>
              <b>Assigned to:</b>
              <ul>
                <li>Zooming and Dragging: Christian</li>
                <li>Linking and Brushing, UI: Sonja</li>
              </ul>
            </p>
            <p><b>Due:</b> 3rd December</p>
          </dd>

          <dt>Testing, Debugging and adding some polish (e.g. usability)</dt>
          <dd>
            <p>
              Since interactive parts are almost guaranteed to be weird and buggy
              at first, test, test and then test some more. Maybe let strange people
              play with it. Get feedback and try not to argue with them.
            </p>

            <p>
              <b>Assigned to:</b> all
            </p>
            <p><b>Due:</b> 10th December with days to spare</p>
          </dd>
        </dl>

        <h4>Maybe's, stretch goals</h4>
        <ul>
          <li>Maybe let the user select a start point for the algorithm to explore its relevance</li>
          <li>Maybe let the user define a select next logic (first/last unexplored,random, min/max in some
            dimension)
          </li>
        </ul>
    </section>

    <section id="m3">
        <h2>Milestone 3</h2>
        coming soonish
    </section>

    <section id="m4">
        <h2>Milestone 4</h2>

        coming eventually
    </section>
</div>
</body>
</html>
